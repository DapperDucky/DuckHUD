# This is a file describing a standard autoconfiguration, do not edit.
# See custom/sample.conf for a more generic template and explanation on the syntax.

name: Duck Hud - Wreaker - 0.0.0

slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofuel:
        class: AtmoFuelContainer
        select: all
    spacefuel:
        class: SpaceFuelContainer
        select: all
    rocketfuel:
        class: RocketFuelContainer
        select: all
    gyro:
        class: GyroUnit
    shield:
        class: ShieldGeneratorUnit
    weapon:
        class: WeaponUnit
        select: manual
    radar:
        class: RadarPVPUnit
        select: all
    databank:
        class: databank
handlers:
    unit:
        onStart:
            lua: |
                -- category panel display helpers
                _autoconf = {}
                _autoconf.panels = {}
                _autoconf.panels_size = 0
                _autoconf.displayCategoryPanel = function(elements, size, title, type, widgetPerData)
                    widgetPerData = widgetPerData or false -- default to one widget for all data
                    if size > 0 then
                        local panel = system.createWidgetPanel(title)
                        local widget
                        if not widgetPerData then
                            widget = system.createWidget(panel, type)
                        end
                        for i = 1, size do
                            if widgetPerData then
                                widget = system.createWidget(panel, type)
                            end
                            system.addDataToWidget(elements[i].getWidgetDataId(), widget)
                        end
                        _autoconf.panels_size = _autoconf.panels_size + 1
                        _autoconf.panels[_autoconf.panels_size] = panel
                    end
                end
                _autoconf.hideCategoryPanels = function()
                    for i=1,_autoconf.panels_size do
                        system.destroyWidgetPanel(_autoconf.panels[i])
                    end
                end
                -- Proxy array to access auto-plugged slots programmatically

                atmofuel = {}
                atmofuel[1] = atmofuel_1
                atmofuel[2] = atmofuel_2
                atmofuel_size = 2

                spacefuel = {}
                spacefuel[1] = spacefuel_1
                spacefuel[2] = spacefuel_2
                spacefuel_size = 2

                rocketfuel = {}
                rocketfuel_size = 0

                weapon = {}
                weapon_size = 0

                radar = {}
                radar[1] = radar_1
                radar_size = 1
                -- End of auto-generated code

                IsBraking = false --export
                IsArActive = true --export
                EnableAR = true --export
                MaxArDist = 500 --export
                MaxSatArDist = 25 --export
                MaxRoidArDist = 17.5 --export
                ShowHelper = false --export
                TimeAdjustMinutes = 0 --export
                Show_Trajectory = true --export
                Show_Forward = true --export
                Flight_Mode = 0 --export
                Content = ''
                PreventBurn = false
                ScreenHeight = system.getScreenHeight()
                ScreenWidth = system.getScreenWidth()
                ScreenHalfWidth = math.floor(ScreenWidth/2)
                SHW = math.floor(ScreenWidth/2)
                SHH = math.floor(ScreenHeight/2)
                Tick = 0
                Init = false
                InSpace = false
                WayPoints = {}
                SelectedWayPoint = nil
                WayPointClearHold = 0
                WayPointClearHoldMax = 10
                SweepContent = ''
                Shade = 0
                Speed = 0
                UIColor = '245,245,245'

                AtmoFuelPerc = 0
                SpaceFuelPerc = 0

                CurrentPage=1
                pitchInput=0
                rollInput=0
                yawInput=0
                brakeInput=0

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                Nav.axisCommandManager:setTargetGroundAltitude(0)
                placeRadar = true

                gearExtended = unit.isAnyLandingGearDeployed()
                if gearExtended then unit.deployLandingGears()else unit.retractLandingGears()end

                system.showHelper(ShowHelper)
                unit.setTimer('draw',0.05)
                unit.setTimer('data',0.25)
                unit.setTimer('radar',0.25)
                unit.setTimer('fuel',0.25)

                system.print('Duck Hud - Wreaker - v0.0.0')

                if gyro == nil then system.print('NO GYRO INSTALLED > Avionics has been disabled') end

                if databank == nil then system.print('NO DATABANK INSTALLED > Custom waypoints has been disabled') end

        onStop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hideWidget() end
                if warpdrive ~= nil then warpdrive.hideWidget() end
                if gyro ~= nil then gyro.hideWidget() end
                core.hideWidget()
                unit.switchOffHeadlights()
        onTimer:
            args: [draw]
            lua: Draw()
        onTimer:
            args: [data]
            lua: |
                if not Init then
                    Init = true
                    GetWayPoints()
                else
                    InSpace = not (unit.getAtmosphereDensity() > 0 or core.getAltitude() > 0)
                end
        onTimer:
            args: [radar]
            lua: |
                SweepContent = ''
                Sweep(radar_1)
                Sweep(radar_2)
        onTimer:
            args: [fuel]
            lua: |
                AtmoFuelPerc = GetFuelPerc(atmofuel)
                SpaceFuelPerc = GetFuelPerc(spacefuel)
    system:
        onFlush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(construct.getWorldOrientationUp())
                local constructForward = vec3(construct.getWorldOrientationForward())
                local constructRight = vec3(construct.getWorldOrientationRight())
                local constructVelocity = vec3(construct.getWorldVelocity())
                local constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(construct.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we do not go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        onUpdate:
            lua: |
                Nav:update()
                Tick = Tick + 0.1

        onActionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    unit.deployLandingGears()
                else
                    unit.retractLandingGears()
                end

        onActionStart:
            args: [light]
            lua: |
                if unit.isAnyHeadlightSwitchedOn() then
                    unit.switchOffHeadlights()
                else
                    unit.switchOnHeadlights()
                end

        onActionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        onActionStart(action):
            lua: --system.print(action)
        onActionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        onActionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        onActionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        onActionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        onActionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        onActionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        onActionStop:
            args: [right]
            lua: rollInput = rollInput - 1

        onActionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        onActionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        onActionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        onActionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        onActionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        onActionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        onActionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        onActionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        onActionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        onActionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        onActionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        onActionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        onActionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        onActionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        onActionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        onActionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1
        onActionStart:
            args: [brake]
            lua: |
                IsBraking = not IsBraking
                brakeInput = Ternary(IsBraking,1,0)
        onActionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        onActionStart:
            args: [stopengines]
            lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        onActionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        onActionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        onActionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        onActionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)
        onActionStart:
            args: [option1]
            lua: if SelectedWayPoint~=nil and SelectedWayPoint<#WayPoints then SelectedWayPoint=SelectedWayPoint+1 else SelectedWayPoint=1 end
        onActionLoop:
            args: [option1]
            lua: |
                if WayPointClearHold > WayPointClearHoldMax then SelectedWayPoint = nil end
                WayPointClearHold = WayPointClearHold + 0.5
        onActionStop:
            args: [option1]
            lua: WayPointClearHold = 0
        onActionStart:
            args: [option8]
            lua: Shade = Ternary(Shade + 0.025 > 1, 1, Shade + 0.025)
        onActionStart:
            args: [option9]
            lua: Shade = Ternary(Shade - 0.025 < 0, 0, Shade - 0.025)
        onActionStart:
            args: [option2]
            lua: |
                if #WayPoints > 0 and SelectedWayPoint ~= nil then system.setWaypoint(WayPoints[SelectedWayPoint].s) end
        onActionStart:
            args: [option3]
            lua: |
                local sze = getSafeZoneEdgeVec3()
                system.setWaypoint([[::pos{0,0,]]..sze.x..[[,]]..sze.y..[[,]]..sze.z..[[}]])
        inputText(text):
            lua: |
                system.print('PRINT: '..text)

                local t = Split(text, ' ')

                if t[1] == 'wp' then
                    if #t > 2 then
                        local p = PosToToWorld(t[2])
                        local n = table.concat(t, ' ', 3)
                        databank.setStringValue([[wp]]..#WayPoints+1,n..[[~]]..p.x..[[~]]..p.y..[[~]]..p.z..[[~]]..t[2])
                        system.print(n..[[~]]..p.x..[[~]]..p.y..[[~]]..p.z..[[~]]..t[2])
                        GetWayPoints()
                    else
                        system.print('Bad Waypoint: Waypoints should be in the form of "wp pos name"')    
                    end
                elseif t[1] == 'ag' then
                    if t[2] ~= nil and tonumber(t[2]) ~= nil then
                        antigrav.setTargetAltitude(tonumber(t[2]))
                        system.print('Target Altitude Set To '.. tonumber(t[2]))
                    elseif t[2] == 'on' or t[2] == 'engage' then
                        antigrav.activate()
                        system.print('Antigrav Engaged')
                    elseif t[2] == 'off' or t[2] == 'disengage' then
                        antigrav.deactivate()
                        system.print('Antigrav Disengaged')
                    else
                        system.print('Bad Antigrav Command: Should be in form "ag altitude"')
                    end
                elseif t[1] == 'db' and t[2] ~= nil then
                    if t[2] == 'clear' then
                        databank.clear()
                        system.print('Databank Cleared')
                        GetWayPoints()
                    else
                        system.print('Bad Databank Command: Should be in form "db cmd"')
                    end
                else
                    system.print('Unkown Text Command: '..text)
                end
                
    radar_1:
        enter(id):
            lua: |
                OnContact(radar_1,id)
        leave(id):
            lua: |
                -- TODO
    radar_2:
        enter(id):
            lua: |
                OnContact(radar_2,id)
        leave(id):
            lua: |
                -- TODO
    library:
        onStart:
            lua: |
                local Atlas=require("atlas")

                TypeColor = {t1 = '42,255,255',t2 = '255,42,255',t3 = '255,255,42',t4 = '42,255,255',t5 = '255,42,255',t6 = '255,255,42',t7 = '42,255,42'}
                SafeZone = {center = vec3(13771471.0510,7435803.0486,-128971.9622),radius = 18000000}

                WarpStart = {}
                WarpStart[1] = 'Idle'
                WarpStart[2] = 'Engaged'
                WarpStart[3] = 'Align'
                WarpStart[4] = 'Spool'
                WarpStart[5] = 'Accel'
                WarpStart[6] = 'Cruise'
                WarpStart[7] = 'Decel'
                WarpStart[8] = 'Stop'
                WarpStart[9] = 'Diseng'

                WarpState = {}
                WarpState[#WarpState+1] = 'No Warp Drive'
                WarpState[#WarpState+1] = 'Broken'
                WarpState[#WarpState+1] = 'Warping'
                WarpState[#WarpState+1] = 'Parent Warping' 
                WarpState[#WarpState+1] = 'Not Anchored'
                WarpState[#WarpState+1] = 'Cooldown' 
                WarpState[#WarpState+1] = 'Cooldown'
                WarpState[#WarpState+1] = 'Moving Child'
                WarpState[#WarpState+1] = 'No Container'
                WarpState[#WarpState+1] = 'Planet Too Close'
                WarpState[#WarpState+1] = 'No Destination'
                WarpState[#WarpState+1] = 'Destination Too Close' 
                WarpState[#WarpState+1] = 'Destination Too Far'
                WarpState[#WarpState+1] = 'Not Enough Warp Cells'
                WarpState[#WarpState+1] = 'Ready'

                CurrentNavId=1
                PlanetDetails={}
                AtlasIds={}
                DegToRadians = math.pi/180.0
                RadiansToDeg = 180.0/math.pi
                function Ternary(c,x,y)if c then return x else return y end end
                function BuildCores(this)return BuildGeneric(this)end
                function SetPageContent(content)return[[<svg width="100%" height="100%" style="position:absolute;left:0%;top:0%;background-color:rgba(42,255,42,0);">]]..content..[[</svg>]]end
                function AddDefs()return[[<defs></defs>]]end
                function ToPrettyDistanceTemp(m)return Ternary(math.ceil(m/1000) < 100, math.floor(math.ceil(m/1000)*100)/100 ..[[km]], math.floor((math.ceil(m/1000)/200)*100)/100 ..[[su]])end
                function GetPerc(x,y)return math.floor((x/y)*100)end
                function GetPercNum(x,y)return math.floor((x*y)/100)end
                function ConvertLocalToWorld(a,b,c,d,e)local f={a[1]*c[1],a[1]*c[2],a[1]*c[3]}local g={a[2]*d[1],a[2]*d[2],a[2]*d[3]}local h={a[3]*e[1],a[3]*e[2],a[3]*e[3]}return{f[1]+g[1]+h[1]+b[1],f[2]+g[2]+h[2]+b[2],f[3]+g[3]+h[3]+b[3]}end
                function GetSize(s,d)return math.atan(s,d)*2000 end
                function CalcDist(v1,v2)return math.abs(math.sqrt(((v1.x-v2.x)^2)+((v1.y-v2.y)^2)+((v1.z-v2.z)^2)))end
                function CalcSpeed(v)return math.floor(math.sqrt(((v.x)^2)+((v.y)^2)+((v.z)^2))*3.6)end
                function CalcSpeedT(v)return math.floor(math.sqrt(((v.x)^2) + ((v.y)^2) + ((v.z)^2)))end
                function Trunc(n,d)return math.modf(n*10^(d))/(10^(d))end
                function Trajectory(a,b,c)return vec3(a)+(vec3(b)*c)end 
                function GetTravelTime(d)return (d/CalcSpeedT(vec3(construct.getWorldAbsoluteVelocity())))end
                function GetCurrentTimeString(o)return GetPrettyTimeString(math.floor(system.getUtcTime()+system.getUtcOffset()+(math.floor(Ternary(o==nil,0,o))+(TimeAdjustMinutes)*60)))end
                function sign(n)return n>0 and 1 or (n==0 and 0 or -1)end
                function GetTop(n,g,m,l) if n < g then return GetTop(n*m,g,m,l) else return Ternary(n < l, n, l) end end

                function FadeColor(c1,c2,p)
                    r = c1.x*(1-p) + c2.x*(p)
                    g = c1.y*(1-p) + c2.y*(p)
                    b = c1.z*(1-p) + c2.z*(p)
                    return vec3(math.floor(r),math.floor(g),math.floor(b))
                end

                function Wave()
                    local amp = Tick * 500
                    local r = math.floor(255 * math.abs(math.sin((amp * DegToRadians))))
                    local g = math.floor(255 * math.abs(math.sin((amp + ((math.pi*RadiansToDeg)/3))* DegToRadians)))
                    local b = math.floor(255 * math.abs(math.sin((amp + (((math.pi*RadiansToDeg)*2)/3))* DegToRadians)))
                    return vec3({r,g,b})    
                end

                for k,v in pairs(Atlas[0]) do AtlasIds[#AtlasIds+1] = k end
                for At,Helios in pairs(Atlas)do
                    for planet,pDetails in pairs(Helios)do
                        PlanetDetails[planet] = {center = vec3(pDetails.center), radius = pDetails.radius}
                    end
                end

                function ToVectorTable(v)
                    local t = {}
                    t[1] = v.x
                    t[2] = v.y
                    t[3] = v.z
                    return t
                end

                function GetBrake()
                    local tb = construct.getMaxThrustAlongAxis()
                    local m = construct.getMaxBrake()
                    local t = 0
                    local d = 0
                    
                    if m ~= nil then
                        local bspeed = vec3(construct.getWorldVelocity()):len()
                        local mass = construct.getMass()
                        local brake_force_m_s2 = m / mass
                        t = bspeed / brake_force_m_s2
                        d = utils.round((mass * bspeed * bspeed / (2 * m))*100)/100
                    end
                    return {Time = t, Dist = d}
                end

                function Split(s, d)
                    result = {}
                    for match in (s..d):gmatch([[(.-)]]..d) do table.insert(result, match) end
                    return result
                end

                function PosToToWorld(planetPos)
                    local latRotateAxis = vec3(0,1,0)
                    local longRotateAxis = vec3(0,0,1)
                    local planetId, lat, long, alt = planetPos:match([[::pos{0,([0-9]*),(-?[\.0-9]*),(-?[\.0-9]*),(-?[\.0-9]*)]])
                    planetId = tonumber(planetId)
                    
                    if(planetId == 0) then return vec3(lat, long, alt) end
                    
                    lat = (90-lat) * DegToRadians
                    long = long * DegToRadians
                    
                    local vecToLoc = vec3(0,0,(tonumber(alt)+PlanetDetails[planetId].radius))
                    vecToLoc = vecToLoc:rotate(lat,latRotateAxis)
                    vecToLoc = vecToLoc:rotate(long,longRotateAxis)
                    
                    return PlanetDetails[planetId].center+vecToLoc
                end

                function Draw()
                    Speed = CalcSpeed(vec3(construct.getAbsoluteVelocity()))
                    if Speed < 70000 then UIColor = '245,245,245' else local w = Wave(); UIColor = w.x..[[,]]..w.y..[[,]]..w.z; end 
                    system.showScreen(EnableAR)
                    if EnableAR then system.setScreen(SetPageContent(GetContent())) end
                end

                function GetContent()
                    
                    if Flight_Mode == 0 then
                    return AddDefs()..[[
                        <rect x="0" y="0" width="]]..ScreenWidth..[[" height="]]..ScreenHeight..[[" fill="rgba(0,0,0,]]..Shade..[[)"/>
                        ]]..DrawPoints()..[[
                        ]]..DrawTraject()..[[
                        ]]..DrawBottomBar()..[[
                        ]]..DrawTopBar()..[[
                        ]]..SweepContent
                    else
                        return AddDefs()..[[
                        <rect x="0" y="0" width="]]..ScreenWidth..[[" height="]]..ScreenHeight..[[" fill="rgba(0,0,0,]]..Shade..[[)"/>
                        ]]
                    end
                end

                function PointAroundOrigin(origin,target)
                    local vec2 = target - origin
                    local vec1 = vec3(0,1,0)
                    return math.atan(vec2.y, vec2.x) - math.atan(vec1.y, vec1.x)
                end

                function PointAroundOriginTest()
                    local vec2 = ((vec3(core.getWorldGravity()) * 1000) + vec3(construct.getWorldPosition())) - vec3(construct.getWorldPosition())
                    local vec1 = vec3(construct.getForward()) * vec3(construct.getWorldOrientationForward())
                    return math.atan(vec2.y, vec2.x) - math.atan(vec1.y, vec1.x)
                end

                function Rotate(x,y,a,p)
                    local s = math.sin(a)
                    local c = math.cos(a)

                    p.x = p.x - x
                    p.y = p.y - y

                    local newx = p.x * c - p.y * s
                    local newy = p.x * s + p.y * c

                    p.x = newx + x
                    p.y = newy + y
                    return {x = p.x, y = p.y} 
                end

                function GetPrettyTimeString(t)
                local allseconds = math.floor(Ternary(t == nil, 0, t))
                local daySeconds = math.floor(allseconds % 86400)
                local hoursPassed = math.floor(daySeconds / 3600)
                local minutesPassed = math.floor((daySeconds % 3600) / 60)
                local secondsPassed = math.floor((daySeconds % 3600) % 60)
                return string.format("%02d",Ternary(hoursPassed > 0, hoursPassed, 0))..[[:]]..string.format("%02d",Ternary(minutesPassed>0,minutesPassed,0))..[[:]]..string.format("%02d",Ternary(secondsPassed>0,secondsPassed,0))
                end

                function DrawPoints()
                    c = ''
                    for k,v in pairs(Atlas[0]) do
                        local dist = CalcDist(vec3(construct.getWorldPosition()),vec3(v.center))
                        local screenpos = library.getPointOnScreen(v.center)
                        local isOnScreen = (math.abs(screenpos[1]) < 1) and (math.abs(screenpos[2]) < 1) and (math.abs(screenpos[1]) > 0) and (math.abs(screenpos[2]) > 0)
                        local isPlanetInRange = dist < MaxArDist * 200000 and v.type[1] == "Planet"
                        local isSatInRange = dist < MaxSatArDist * 200000 and v.type[1] ~= "Moon"
                        local isRoidInRange = dist < MaxRoidArDist * 200000 and v.type[1] ~= "Asteroid"
                        
                        if isOnScreen and (isPlanetInRange or isSatInRange or isRoidInRange) then
                            local r = GetSize(v.radius, dist)
                            local hr = math.floor(r/2)
                            local qr = math.floor(r/4)
                            local color = [[rgba(255,255,42,0.7)]]
                            
                            if isSatInRange then color = [[rgba(255,255,42,0.7)]] elseif isRoidInRange then color = [[rgba(255,42,255,0.7)]] end
                            
                            if dist < 200000 then
                                c = c .. [[
                                <g style="transform: translate(]]..GetPercNum(screenpos[1]*100, ScreenWidth)..[[px, ]]..GetPercNum(screenpos[2]*100, ScreenHeight)..[[px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);">
                                    <text x="0" y="-5" font-size="12px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..v.name[1]..[[</text>
                                    <text x="0" y="5" font-size="12px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..ToPrettyDistanceTemp(dist)..[[</text>
                                </g>
                                ]]
                            elseif isPlanetInRange and dist < (75 * 200000) and dist > 200000 then
                                c = c .. [[
                                <g style="transform: translate(]]..GetPercNum(screenpos[1]*100, ScreenWidth)..[[px, ]]..GetPercNum(screenpos[2]*100, ScreenHeight)..[[px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);">
                                    <text x="]]..Ternary(dist < 200000,0,-(r+30))..[[" y="]]..Ternary(dist < 200000,0,-r+10)..[[" font-size="12px" font-weight="bold" fill="rgba(255,255,42,0.7)" text-anchor="middle" dominant-baseline="middle">]]..v.name[1]..[[</text>
                                    <text x="]]..Ternary(dist < 200000,0,-(r+30))..[[" y="]]..Ternary(dist < 200000,0,-r+20)..[[" font-size="12px" font-weight="bold" fill="rgba(255,255,42,0.7)" text-anchor="middle" dominant-baseline="middle">]]..ToPrettyDistanceTemp(dist)..[[</text>
                                    <g style="transform: translate(0px, 0px) rotateX(0deg) rotateY(0deg) rotateZ(]]..Tick*3 ..[[deg);">
                                        <path fill="none" stroke="]]..color..[[" stroke-width="8" d="M]]..0 ..[[,]].. r..[[ a]].. r..[[,]].. r..[[ 1 0,1 ]]..-r..[[,]]..-r..[[" />
                                        <path fill="none" stroke="]]..color..[[" stroke-width="8" d="M]]..0 ..[[,]]..-r..[[ a]]..-r..[[,]]..-r..[[ 1 0,1 ]].. r..[[,]].. r..[[" />
                                    </g>
                                </g>
                                ]]
                            elseif dist < (75 * 200000) and dist > 200000 then
                                c = c .. [[
                                <g style="transform: translate(]]..GetPercNum(screenpos[1]*100, ScreenWidth)..[[px, ]]..GetPercNum(screenpos[2]*100, ScreenHeight)..[[px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);">
                                    <text x="]]..Ternary(dist < 200000,0,-(r+30))..[[" y="]]..Ternary(dist < 200000,0,-r+10)..[[" font-size="12px" font-weight="bold" fill="rgba(255,255,42,0.7)" text-anchor="middle" dominant-baseline="middle">]]..v.name[1]..[[</text>
                                    <text x="]]..Ternary(dist < 200000,0,-(r+30))..[[" y="]]..Ternary(dist < 200000,0,-r+20)..[[" font-size="12px" font-weight="bold" fill="rgba(255,255,42,0.7)" text-anchor="middle" dominant-baseline="middle">]]..ToPrettyDistanceTemp(dist)..[[</text>
                                    <g style="transform: translate(0px, 0px) rotateX(0deg) rotateY(0deg) rotateZ(]]..Tick*3 ..[[deg);">
                                        <circle fill="rgba(255,255,42,0.65)" cx="0" cy="0" r="]]..10 ..[["/>
                                    </g>
                                </g>
                                ]]
                            elseif dist >= (75 * 200000) then
                                c = c .. [[
                                <g style="transform: translate(]]..GetPercNum(screenpos[1]*100, ScreenWidth)..[[px, ]]..GetPercNum(screenpos[2]*100, ScreenHeight)..[[px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);">
                                    <text x="]]..-(r+10)..[[" y="]]..-r..[[" font-size="12px" font-weight="bold" fill="rgba(255,255,42,0.7)" text-anchor="end">]]..v.name[1]..[[</text>
                                    <text x="]]..-(r+10)..[[" y="]]..-r+10 ..[[" font-size="12px" font-weight="bold" fill="rgba(255,255,42,0.7)" text-anchor="end">]]..ToPrettyDistanceTemp(dist)..[[</text>
                                    <g style="transform: translate(0px, 0px) rotateX(0deg) rotateY(0deg) rotateZ(]]..Tick*5 ..[[deg);">
                                        <circle fill="]]..color..[[" cx="0" cy="0" r="5" />
                                    </g>
                                </g>
                                ]]
                            end
                        end
                    end
                    return c
                end
                    
                function DrawTraject()
                    local c = [[]]
                    
                    if CalcSpeed(vec3(construct.getAbsoluteVelocity())) > 10 then
                        local sp1 = library.getPointOnScreen(ToVectorTable(Trajectory(construct.getWorldPosition(),construct.getWorldVelocity(),200000)))
                        local sp2 = library.getPointOnScreen(ToVectorTable(Trajectory(construct.getWorldPosition(),construct.getWorldVelocity(),2)))
                        local sp3 = library.getPointOnScreen(ToVectorTable(Trajectory(construct.getWorldPosition(),construct.getWorldForward(),200000)))
                        
                        if Show_Trajectory then
                            c = [[
                        <g style="transform: translate(]]..GetPercNum(sp1[1]*100, ScreenWidth)..[[px, ]]..GetPercNum(sp1[2]*100, ScreenHeight)..[[px) rotateX(]]..GetPercNum(sp1[2]*100,120)-60 ..[[deg) rotateY(]]..GetPercNum(sp1[1]*100,120)-60 ..[[deg) rotateZ(0deg);">
                            <line x1="0" y1="-40" x2="0" y2="-20" stroke="rgba(255,42,255,0.65)" stroke-width="5" style="transform: rotateZ(0deg)"/>
                            <line x1="0" y1="-40" x2="0" y2="-20" stroke="rgba(255,42,255,0.65)" stroke-width="5" style="transform: rotateZ(120deg)"/>
                            <line x1="0" y1="-40" x2="0" y2="-20" stroke="rgba(255,42,255,0.65)" stroke-width="5" style="transform: rotateZ(240deg)"/>
                        </g>
                        <g style="transform: translate(]]..GetPercNum(sp2[1]*100, ScreenWidth)..[[px, ]]..GetPercNum(sp2[2]*100, ScreenHeight)..[[px) rotateX(]]..GetPercNum(sp2[2]*100,120)-60 ..[[deg) rotateY(]]..GetPercNum(sp2[1]*100,120)-60 ..[[deg) rotateZ(0deg);">
                            <path fill="none" stroke="rgba(255,42,255,0.65)" stroke-width="5" d="M0,-20 a-20,-20 1 0,1 20,20" style="transform: rotateZ(15deg)"/>
                            <path fill="none" stroke="rgba(255,42,255,0.65)" stroke-width="5" d="M0,-20 a-20,-20 1 0,1 20,20" style="transform: rotateZ(135deg)"/>
                            <path fill="none" stroke="rgba(255,42,255,0.65)" stroke-width="5" d="M0,-20 a-20,-20 1 0,1 20,20" style="transform: rotateZ(255deg)"/>
                        </g>
                        ]]
                        end
                        
                        if Show_Forward then
                            c = c .. [[
                            <g style="transform: translate(]]..GetPercNum(sp3[1]*100, ScreenWidth)..[[px, ]]..GetPercNum(sp3[2]*100, ScreenHeight)..[[px) rotateX(]]..GetPercNum(sp3[2]*100,120)-60 ..[[deg) rotateY(]]..GetPercNum(sp3[1]*100,120)-60 ..[[deg) rotateZ(0deg);">
                                <circle fill="rgba(255,255,42,0.65)" cx="0" cy="0" r="5"/>
                                <line x1="0" y1="-40" x2="0" y2="-20" stroke="rgba(245,245,42,0.65)" stroke-width="5" style="transform: rotateZ(60deg)"/>
                                <line x1="0" y1="-40" x2="0" y2="-20" stroke="rgba(245,245,42,0.65)" stroke-width="5" style="transform: rotateZ(180deg)"/>
                                <line x1="0" y1="-40" x2="0" y2="-20" stroke="rgba(245,245,42,0.65)" stroke-width="5" style="transform: rotateZ(300deg)"/>
                            </g>
                            ]]
                        end
                    end
                    return c
                end

                function DrawBrake()
                    local brake = GetBrake()
                    return [[
                    <g style="transform: translate(0px, 15px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);opacity:]]..Ternary(IsBraking,1,0.65)..[[;">
                        <rect x="-125" y="0" width="250" height="60" style="fill:rgba(]]..Ternary(IsBraking,255,84)..[[,42,42,0.65);" rx="5" stroke="rgba(255,255,255,0.0)" stroke-width="2"/>
                        <text x="0" y="15" font-size="24px" font-weight="bold" fill="rgba(245,245,245,]]..Ternary(IsBraking,1,0.35)..[[)" text-anchor="middle" dominant-baseline="middle">ENGAGED</text>
                        <text x="-60" y="34" font-size="12px" font-weight="normal" fill="rgba(245,245,245,1)" text-anchor="middle" dominant-baseline="middle">ETA</text>
                        <text x="60" y="34" font-size="12px" font-weight="normal" fill="rgba(245,245,245,1)" text-anchor="middle" dominant-baseline="middle">Dist</text>
                        <text x="-60" y="50" font-size="18px" font-weight="bold" fill="rgba(245,245,42,1)" text-anchor="middle" dominant-baseline="middle">]]..GetPrettyTimeString(Ternary(brake.Time == nil or brake.Time <= 0, 0, brake.Time))..[[</text>
                        <text x="60" y="50" font-size="18px" font-weight="bold" fill="rgba(245,245,42,1)" text-anchor="middle" dominant-baseline="middle">]]..ToPrettyDistanceTemp(Ternary(brake.Dist == nil or brake.Dist <= 0 or brake.Dist == math.huge, 0, brake.Dist))..[[</text>
                    </g>
                    ]]
                end

                function DrawBottomBar()
                    local sf = GetPercNum(SpaceFuelPerc, 500) --]]..FadeColor2(vec3{255,255,42},vec3{255,42,255},vec3{255,255,42},Tick/ 1.0)..[[
                    local af = GetPercNum(AtmoFuelPerc, 500)
                    local aa = CalcSpeedT(vec3(construct.getAcceleration()))
                    local acct = Ternary(aa < 3, 3, aa)
                    local white = GetPercNum(GetPerc(acct,125), 203)
                    
                    return [[
                    <g style="transform: translate(]]..SHW..[[px,]]..ScreenHeight..[[px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);opacity:1;">
                        <g style="transform: translate(0px, -80px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);opacity:1;">
                            <rect x="-100" y="-80" width="200" height="0" style="fill:rgba(42,42,42,0.65);" rx="5" stroke="rgba(255,255,255,0.0)" stroke-width="2"/>
                            <text x="0" y="-65" font-size="42px" font-weight="bold" fill="rgba(]]..UIColor..[[,0.85)" text-anchor="middle" dominant-baseline="middle">]]..Speed..[[</text>
                            <text x="60" y="-34" font-size="12px" font-weight="normal" fill="rgba(245,245,245,0.65)" text-anchor="middle" dominant-baseline="middle">MAX</text>
                            <text x="60" y="-20" font-size="18px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..math.ceil(construct.getMaxSpeed()*3.6)..[[</text>
                            <text x="-60" y="-34" font-size="12px" font-weight="normal" fill="rgba(245,245,245,0.65)" text-anchor="middle" dominant-baseline="middle">BURN</text>
                            <text x="-60" y="-20" font-size="18px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..math.ceil(construct.getFrictionBurnSpeed()*3.6)..[[</text>
                            <circle fill="rgba(245,245,245,0.65)" cx="0" cy="-25" r="8"/>
                            <line x1="0" y1="-32" x2="0" y2="-55" stroke="rgba(255,255,255,0.325)" stroke-width="5"/>
                            <g style="transform: translate(0px, -25px) rotateX(80deg) rotateY(0deg) rotateZ(]]..Tick*acct..[[deg);">
                                <path fill="none" stroke="rgba(245,]]..245-white..[[,]]..245-white..[[,0.65)" stroke-width="20" d="M0,175 a175,175 1 0,1 -175,-175" />
                                <path fill="none" stroke="rgba(245,]]..245-white..[[,]]..245-white..[[,0.65)" stroke-width="20" d="M0,-175 a-175,-175 1 0,1 175,175" />
                            </g>
                            ]]..DrawBrake()..[[
                        </g>
                        <g style="transform: translate(250px, -120px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);opacity:1;">
                            <rect x="0" y="65" width="500" height="5" style="fill:rgba(245,245,245,0.25);"/>
                            <rect x="-56" y="65" width="56" height="18" style="fill:rgba(245,245,245,0.25);"/>
                            <text x="-56" y="57" font-size="18px" font-weight="normal" fill="rgba(245,245,245,0.65)" text-anchor="start" dominant-baseline="middle">ATMO</text>
                            <rect x="0" y="70" width="]]..af..[[" height="13" style="fill:rgba(84,84,255,0.65);"/>
                            <text x="-28" y="76" font-size="16px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..Ternary(AtmoFuelPerc > 0,AtmoFuelPerc,0)..[[%</text>
                        </g>
                        <g style="transform: translate(-750px, -120px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);opacity:1;">
                            <rect x="0" y="65" width="500" height="5" style="fill:rgba(245,245,245,0.25);"/>
                            <rect x="500" y="65" width="56" height="18" style="fill:rgba(245,245,245,0.25);"/>
                            <text x="556" y="57" font-size="18px" font-weight="normal" fill="rgba(245,245,245,0.65)" text-anchor="end" dominant-baseline="middle">SPACE</text>
                            <rect x="]]..500-sf..[[" y="70" width="]]..sf..[[" height="13" style="fill:rgba(255,255,42,0.65);"/>
                            <text x="528" y="76" font-size="16px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..Ternary(SpaceFuelPerc > 0,SpaceFuelPerc,0)..[[%</text>
                        </g>
                    </g>
                    ]]
                end

                function DrawTopBar()
                    local c = ''
                    local inPvp = construct.isInPvPZone()
                    local distToSZ = construct.getDistanceToSafeZone()
                    local time = GetCurrentTimeString(0)
                    local agActive = false
                    if antigrav ~= nil then agActive = antigrav.isActive() end
                    
                    if warpdrive ~= nil and warpdrive.getDestination() > 0 then
                        local d = warpdrive.getDistance()
                        c = [[
                        <text x="0" y="-32" font-size="22px" font-weight="bold" fill="rgba(245,42,245,0.65)" text-anchor="middle" dominant-baseline="middle">]]..warpdrive.getDestinationName()..[[</text>
                        <rect x="-90" y="-21" width="180" height="16" style="fill:rgba(]]..UIColor..[[,0.65);" rx="5" />
                        <text x="60" y="-12" font-size="14px" font-weight="normal" fill="rgba(42,42,42,1)" text-anchor="middle" dominant-baseline="middle">DIST</text>
                        <text x="60" y="7" font-size="14px" font-weight="bold" fill="rgba(245,245,42,0.65)" text-anchor="middle" dominant-baseline="middle">]]..ToPrettyDistanceTemp(d)..[[</text>
                        <text x="0" y="-12" font-size="14px" font-weight="normal" fill="rgba(42,42,42,1)" text-anchor="middle" dominant-baseline="middle">COST</text>
                        <text x="0" y="7" font-size="14px" font-weight="bold" fill="rgba(245,245,42,0.65)" text-anchor="middle" dominant-baseline="middle">]]..warpdrive.getRequiredWarpCells()..[[</text>
                        <text x="-60" y="-12" font-size="14px" font-weight="normal" fill="rgba(42,42,42,1)" text-anchor="middle" dominant-baseline="middle">CELLS</text>
                        <text x="-60" y="7" font-size="14px" font-weight="bold" fill="rgba(245,245,42,0.65)" text-anchor="middle" dominant-baseline="middle">]]..warpdrive.getAvailableWarpCells()..[[</text>
                        <text x="0" y="35" font-size="16px" font-weight="bold" fill="rgba(42,245,245,0.65)" text-anchor="middle" dominant-baseline="middle">]]..WarpState[warpdrive.getStatus()]..[[</text>
                        ]]
                    elseif SelectedWayPoint ~= nil then 
                        local wp = WayPoints[SelectedWayPoint]
                        local d = CalcDist(wp,vec3(construct.getWorldPosition()))
                        c = [[
                        <text x="0" y="-32" font-size="22px" font-weight="bold" fill="rgba(245,42,245,0.65)" text-anchor="middle" dominant-baseline="middle">]]..wp.Name..[[</text>
                        <rect x="-90" y="-21" width="180" height="16" style="fill:rgba(235,235,235,0.65);" rx="5" />
                        <text x="60" y="-12" font-size="14px" font-weight="normal" fill="rgba(42,42,42,1)" text-anchor="middle" dominant-baseline="middle">DIST</text>
                        <text x="60" y="7" font-size="14px" font-weight="bold" fill="rgba(245,245,42,0.65)" text-anchor="middle" dominant-baseline="middle">]]..ToPrettyDistanceTemp(d)..[[</text>
                        <text x="-60" y="-12" font-size="14px" font-weight="normal" fill="rgba(42,42,42,1)" text-anchor="middle" dominant-baseline="middle">ETA</text>
                        <text x="-60" y="7" font-size="14px" font-weight="bold" fill="rgba(245,245,42,0.65)" text-anchor="middle" dominant-baseline="middle">]]..GetPrettyTimeString(GetTravelTime(d))..[[</text>
                        ]]
                    end

                    return [[
                    <g style="transform: translate(]]..SHW..[[px,5px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);opacity:1[[;">
                        <g style="transform: translate(0px, 45px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);opacity:1[[;">
                            <line x1="-100" y1="-12" x2="-100" y2="50" stroke="rgba(245,245,245,0.25)" stroke-width="3"/>
                            <line x1="100" y1="-12" x2="100" y2="50" stroke="rgba(245,245,245,0.25)" stroke-width="3"/>
                            <line x1="-100" y1="0" x2="-500" y2="0" stroke="rgba(245,245,245,0.25)" stroke-width="3"/>
                            <line x1="100" y1="-0" x2="500" y2="0" stroke="rgba(245,245,245,0.25)" stroke-width="3"/>
                            <rect x="105" y="5" width="315" height="18" style="fill:rgba(]]..UIColor..[[,0.65);" rx="5"/>
                            <rect x="-420" y="5" width="315" height="18" style="fill:rgba(]]..UIColor..[[,0.65);" rx="5"/>
                            <text x="180" y="-10" font-size="18px" font-weight="bold" fill="rgba(]]..UIColor..[[,0.65)" text-anchor="middle" dominant-baseline="middle">ENGAGEMENT</text>        
                            <text x="-185" y="-10" font-size="18px" font-weight="bold" fill="rgba(]]..UIColor..[[,0.65)" text-anchor="middle" dominant-baseline="middle">ENVIRONMENT</text>        
                            <text x="140" y="16" font-size="16px" font-weight="normal" fill="rgba(42,42,42,1.0)" text-anchor="middle" dominant-baseline="middle">DIST</text>
                            <text x="140" y="34" font-size="16px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..ToPrettyDistanceTemp(math.abs(math.floor(distToSZ)))..[[</text>
                            <text x="220" y="16" font-size="18px" font-weight="normal" fill="rgba(42,42,42,1)" text-anchor="middle" dominant-baseline="middle">ZONE</text>
                            <text x="220" y="34" font-size="16px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..Ternary(inPvp,'Unsafe','Safe')..[[</text>
                            <text x="300" y="16" font-size="18px" font-weight="normal" fill="rgba(42,42,42,1)" text-anchor="middle" dominant-baseline="middle">COMBAT</text>
                            <text x="300" y="34" font-size="16px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..GetPrettyTimeString(war)..[[</text>
                            <text x="380" y="16" font-size="18px" font-weight="normal" fill="rgba(42,42,42,1)" text-anchor="middle" dominant-baseline="middle">CORE</text>
                            <text x="380" y="34" font-size="16px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..math.floor(core.getCoreStressRatio()*100)..[[%</text>
                            <text x="-140" y="16" font-size="16px" font-weight="normal" fill="rgba(42,42,42,1.0)" text-anchor="middle" dominant-baseline="middle">MASS</text>
                            <text x="-140" y="34" font-size="16px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..math.ceil(construct.getTotalMass()*0.001) ..[[k</text>
                            <text x="-220" y="16" font-size="18px" font-weight="normal" fill="rgba(42,42,42,1)" text-anchor="middle" dominant-baseline="middle">WARP</text>
                            <text x="-220" y="34" font-size="16px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..WarpStart[construct.getWarpState()]..[[</text>
                            <text x="-300" y="16" font-size="18px" font-weight="normal" fill="rgba(42,42,42,1)" text-anchor="middle" dominant-baseline="middle">TIME</text>
                            <text x="-300" y="34" font-size="16px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..GetCurrentTimeString(0)..[[</text>
                            <text x="-380" y="16" font-size="18px" font-weight="normal" fill="rgba(42,42,42,1)" text-anchor="middle" dominant-baseline="middle">]]..Ternary(antigrav ~= nil, 'AG', '')..[[</text>
                            <text x="-380" y="34" font-size="16px" font-weight="bold" fill="rgba(42,255,255,0.65)" text-anchor="middle" dominant-baseline="middle">]]..Ternary(antigrav ~= nil, Ternary(agActive, 'Active', 'Inactive'), '')..[[</text>
                            ]]..c..[[
                        </g>
                    </g>
                    ]]
                end

                function OnContact(r,id)
                    if not system.isPlayingSound()then system.playSound('alarm.wav')end
                    if r.isConstructAbandoned(id)then system.print('Abandoned Core Found')end
                end

                function Sweep(r)
                    if r ~= nil then
                        local structs = r.getConstructs(0,10,{isMatching = nil, constructKind = 5, coreSize = nil, isAbandoned = nil})
                        if structs ~= nil then
                            SweepContent = SweepContent ..  [[<g style="transform: translate(25px,]]..0 ..[[px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);">]]
                            --system.print(#structs..[[ | ]]..structs[1].name)
                            for k,v in ipairs(structs) do
                                local kind = v.kind
                                SweepContent = SweepContent .. [[
                                <g style="transform: translate(0px,]]..k * 20 ..[[px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);">
                                <rect x="0" y="0" width="300" height="24" style="fill:rgba(42,42,42,0.35);" rx="5" stroke="rgba(245,245,245,]]..Ternary(r.isConstructAbandoned(v.constructId),1,0)..[[)" stroke-width="2"/>
                                <text x="80" y="12" font-size="12px" font-weight="bold" fill="rgba(245,245,245,0.65)" text-anchor="start" dominant-baseline="middle">]]..v.name..[[</text>
                                <text x="5" y="12" font-size="12px" font-weight="bold" fill="rgba(]]..TypeColor['t'..v.constructType]..[[,0.65)" text-anchor="start" dominant-baseline="middle">]]..v.size..[[</text>
                                <text x="50" y="12" font-size="12px" font-weight="bold" fill="rgba(245,245,245,0.65)" text-anchor="middle" dominant-baseline="middle">]]..ToPrettyDistanceTemp(math.abs(math.floor(v.distance)))..[[</text>
                                </g>
                                ]]
                            end
                            SweepContent = SweepContent .. [[</g>]]
                        end
                    end
                end

                function getSafeZoneEdgeVec3()
                    local currentPos = vec3(construct.getWorldPosition())
                    local safeZoneEdgePOS = (currentPos - SafeZone.center):normalize() * SafeZone.radius + SafeZone.center
                    local distance = vec3(currentPos-safeZoneEdgePOS):len()/1000/200 
                    return safeZoneEdgePOS --:unpack()
                end

                function GetFuelPerc(s)
                    local max = 0
                    local cur = 0
                    for k,v in ipairs(s) do 
                        max = max + v.getMaxVolume()
                        cur = cur + v.getItemsVolume()
                    end
                    return GetPerc(cur,max)
                end

                function GetWayPoints()
                    local i = 1
                    WayPoints = {}
                    if databank ~= nil then
                        SelectedWayPoint = nil
                        while databank.hasKey([[wp]]..i) do
                            local v = Split(databank.getStringValue([[wp]]..i),'~')
                            WayPoints[i] = {Name = v[1], x = tonumber(v[2]), y = tonumber(v[3]), z = tonumber(v[4]), s = v[5]}
                            i = i + 1
                        end
                    end
                    system.print([[Waypoints Loaded: ]]..#WayPoints)
                end